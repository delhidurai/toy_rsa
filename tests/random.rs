//Test file for the toy_rsa crate.

use std::convert::TryFrom;
use std::convert::TryInto;

// Test case 1, the below test case test the crate with the below public, private and message
//Private Key: p = 0xed23e6cd q = 0xf050a04d
//  Public Key: p * q = 0xde9c5816141c8ba9
//  Message: 12345

#[test]
fn test_1() {
    let p: u64 = 0xed23e6cd;
    let q: u64 = 0xf050a04d;
    let message: u32 = 12345;
    let public_key: u64 = p * q;
    println!("The given input message to be encrypted is {}", message);
    println!("public key is {}", public_key);
    let encrypt: u64 = toy_rsa::encrypt(public_key, message);
    println!("Encrypted message is {}", encrypt);
    let dc: u64 = toy_rsa::decrypt((p, q), encrypt);
    println!("decrypted Message is {}", i64::try_from(dc).unwrap());
    assert_eq!(12345, dc);
}


// Test case 2, the below test case test the crate with the below public, private and message
//Private Key: p = 61 q = 53
//  Public Key: p * q = 3233
//  Message: 65
#[test]
fn test_2() {
    let p: u64 = 61;
    let q: u64 = 53;
    let message: u32 = 65;
    let public_key: u64 = p * q;
    println!("The given input message to be encrypted is {}", message);
    println!("public key is {}", public_key);
    let encrypt: u64 = toy_rsa::encrypt(public_key, message);
    println!("Encrypted message is {}", encrypt);
    let decrypt: u64 = toy_rsa::decrypt((p, q), encrypt);
    println!("decrypted value {}", decrypt);
    assert_eq!(65, decrypt);
}

// Test case 3, the below test case test the crate with the below public, private and message
//Private Key: p and q will be generated by genkey
//  Public Key: p * q, known only during run time
//  Message: 56789
#[test]
fn test_3() {
    let (p, q): (u32, u32) = toy_rsa::genkey();
    let p_u64 = p.try_into().unwrap();
    let q_u64 = q.try_into().unwrap();
    let message: u32 = 56789;
    let public_key: u64 = p_u64 * q_u64;
    println!("The given input message to be encrypted is {}", message);
    println!("public key is {}", public_key);
    let encrypt: u64 = toy_rsa::encrypt(public_key, message);
    println!("Encrypted message is {}", encrypt);
    let decrypt: u64 = toy_rsa::decrypt((p_u64, q_u64), encrypt);
    println!(
        "decrypted value {}",
        decrypt
    );
    assert_eq!(56789, decrypt);
}

// Test case 4 - Failure scenario, the below test case test the crate for failure scenario with the below public, private and message
//Private Key: p and q will be generated by genkey
//  Public Key: p * q, known only during run time
//  Message: 12345
// Validated against 1122.
// This test should panic
#[test]
#[should_panic]
fn test_4() {
    println!("Executing Failure scenario");
    let (p,q) = toy_rsa::genkey();
    let p_u64 = p.try_into().unwrap();
    let q_u64 = q.try_into().unwrap();
    let public_key = p_u64 * q_u64;
    let message = 12345;
    let encrypt = toy_rsa::encrypt(public_key, message);
    let decrypt: u64 = toy_rsa::decrypt((p_u64, q_u64), encrypt);
    assert_eq!(1122, decrypt);

}


